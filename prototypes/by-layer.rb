require('ostruct')

def default_options
  options = OpenStruct.new
  options.activation_function = CooCoo::ActivationFunctions.from_name('Logistic')
  options.layers = Array.new
  options.softmax = false
  options
end

def option_parser options
  @opts = CooCoo::OptionParser.new do |o|
    o.banner = "Explicit fully connected layers"
    
    o.on('--activation NAME', "The activation function the network uses at each layer. Valid options are: #{CooCoo::ActivationFunctions.named_classes.join(', ')}") do |n|
      options.activation_function = CooCoo::ActivationFunctions.from_name(n)
    end

    o.on('--input-size W,H') do |v|
      options.input_size = CooCoo::Utils.split_csi(v)
      options.layers << [ :input_size, options.input_size ]
    end
    
    o.on('--layer SIZE', 'Add a layer with SIZE neurons.') do |n|
      options.layers << [ :fully_connected, n.to_i, options.activation_function ]
    end

    o.on('--linear ACTIVATION') do |n|
      options.layers << [ :linear, nil, ActivationFunctions.from_name(n) ]
    end

    o.on('--recurrent-layer SIZE', Integer) do |v|
      options.recurrent = true
      options.layers << [ :recurrent_frontend, v ]
    end
    
    o.on('--recurrent-backend') do
      options.recurrent = true
      options.layers << [ :recurrent_backend ]
    end

    o.on('--conv2d WIDTH,HEIGHT') do |v|
      w, h = CooCoo::Utils.split_csi(v)
      options.layers << [ :conv2d, [ w, h ], options.conv_size, options.conv_step ]
    end
    
    o.on('--convolution-box WIDTH,HEIGHT') do |n|
      w, h = CooCoo::Utils.split_csi(n)
      h ||= w
      options.layers << [ :conv_box, [w, h], options.conv_step, options.conv_hidden_out, options.activation_function, (options.conv_updater || :sum).to_sym ]
    end

    o.on('--convolution-step X,Y') do |n|
      x, y = CooCoo::Utils.split_csi(n)
      y ||= x
      raise ArgumentError.new("The convolution step must be >0.") if x <= 0 || y <= 0
      options.conv_step = [ x, y ]
    end

    o.on('--convolution-size X,Y') do |n|
      x, y = CooCoo::Utils.split_csi(n)
      y ||= x
      options.conv_size = [ x, y ]
    end
    
    o.on('--convolution-hidden-out W,H') do |n|
      w, h = CooCoo::Utils.split_csi(n)
      h ||= 1
      options.conv_hidden_out = [ w, h ]
    end

    o.on('--conv-updater NAME') do |v|
      options.conv_updater = v
    end

    o.on('--softmax', 'Adds a SoftMax layer to the end of the network.') do
      options.softmax = true
    end
  end
end

def generate(options, input_size, output_size)
  log.puts("Generating #{options.layers.size} layers for #{options.input_size.inspect} (#{input_size}) inputs to #{output_size} outputs.")

  net = options.recurrent ? CooCoo::TemporalNetwork.new : CooCoo::Network.new
  net.comments << "Generated by #{__FILE__}: %s" % [ options.to_h.inspect ]
  last_size = options.input_size || [ input_size ]
  recurrent = nil

  options.layers.each do |kind, size, *args|
    log.puts("%20s  %-16s %-16s #{args.inspect}" % [ kind, last_size, size ])
    case kind
    when :input_size then
      last_size = size
    when :fully_connected then
      net.layer(CooCoo::Layer.new(last_size.prod, size, args[0]))
      last_size = [ size ]
    when :linear then
      net.layer(layer = CooCoo::LinearLayer.new(last_size.prod, args[0]))
      # last_size = [ layer.size ]
    when :recurrent_frontend then
      recurrent = CooCoo::Recurrence::Frontend.new(last_size.prod, size)
      net.layer(recurrent)
      last_size = [ recurrent.size ]
    when :recurrent_backend then
      net.layer(recurrent.backend)
      last_size = [ recurrent.backend.size ]
    when :conv_box then
      cstep, cout, af, updater = args
      last_size = [ ::Math.sqrt(last_size[0]).to_i ] * 2 if last_size.size == 1
      int_layer = CooCoo::Layer.new(size[0] * size[1], cout[0] * cout[1], af)
      layer = CooCoo::Convolution::BoxLayer.new(*last_size, *cstep, int_layer, *size, *cout, updater)
      net.layer(layer)
      last_size = [ layer.output_width, layer.output_height ]
    when :conv2d
      csize, cstep = args
      inner = CooCoo::Vector.rand(size.prod)
      last_size = [ ::Math.sqrt(last_size[0]).to_i ] * 2 if last_size.size == 1
      layer = CooCoo::Convolution::Conv2dLayer.new(*last_size, *cstep, inner, *size, *csize)
      net.layer(layer)
      last_size = [ layer.output_width, layer.output_height ]
    end
  end

  if last_size.prod != output_size
    log.puts("%20s  %-16s %-16s" % [ :fully_connected, last_size, output_size ])
    net.layer(CooCoo::Layer.new(last_size.prod, output_size, options.activation_function))
  end

  if options.softmax
    log.puts("%20s  %-16s %-16s" % [ :softmax, last_size, output_size ])
    net.layer(CooCoo::LinearLayer.new(last_size.prod, CooCoo::ActivationFunctions::ShiftedSoftMax.instance))
  end

  net
end


[ method(:generate), method(:option_parser), method(:default_options) ]
